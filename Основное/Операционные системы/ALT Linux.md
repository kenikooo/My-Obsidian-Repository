— Перейти в [[HUB]] —
> [!INFO] Содержимое
1. [[#Смена имени на устройстве]]
2. [[#Работа с директориями]]
3. [[#Создание файла]]
4. [[#Получение конфигурации по DHCP]]
5. [[#Работа с apt-get]]
6. [[#Настройка интерфейса]]
7. [[#Отображение списка фалов и каталогов]]
8. [[#Добавление нового пользователя]]
9. [[#Группы для пользователей]]
10. [[#Управление правами]]
11. [[#NAT через iptables]]
12. [[#Samba DC]]
13. [[#Присоединение к домену с помощью realm]]
14. [[#Настройка WireGuard VPN]]
15. [[#Мониторинг системы и сети]]
16. [[#Настройка GRE]]
---
### Смена имени на устройстве
```bash
hostname set-hostname [имя] # не сохранится
hostnamectl set-hostname [имя] # Требуется перезагрузка, сохранится
hostnamectl set-hostname [имя]; exec bash # Без перезагрузки + сохранится
```

### Работа с директориями
- Создание директории:
```bash
mkdir
mkdir -p # Флаг создающий директории в директории, если не существует к примеру двух
> Пример:
> mkdir /etc/net/ifaces/enp0s8
```
- Переименование директории 
```bash
mv изначальное_имя_директории итоговое_имя_директории
> Пример:
> mv /etc/net/ifaces/enp0s9 /etc/net/ifaces/enp0s8
> В дданном примере, директория с именем enp0s9 будет переименована в enp0s8
```
>[!WARNING]
Данная команда предназначена как для переименования какой-то директории, так и для ее переноса в другое место
### Создание файла
#files #touch
```bash
touch
> Пример:
> touch /etc/net/ifaces/enp0s3/ipv4address
> # В данном примере нами был создан файл ipv4address
```

### Получение конфигурации по DHCP
#dhcp
```bash
dhcpd # Получение настроек по DHCP
dhcpd -k # Удаление настроек выданных по DHCP
```

### Работа с apt-get
#apt
```bash
apt-get install [имя пакета] # Установка пакета
apt-get reinstall [имя пакета] # Переустановка пакета
apt-get remove [имя пакета] # Удаление пакета
apt-cache search [имя пакета] # Поиск пакета

> Пример: apt-get install iptables -y
> Флаг -y автоматически подтверждает установку пакета
```

### Настройка интерфейса
#interfaces
```bash
/etc/net/ifaces/[int_name]/ipv4address
/etc/net/ifaces/[int_name]/ipv4route
/etc/net/ifaces/[int_name]/options
```

- Перезагрузка сетевых конфигураций:
```bash
systemctl restart network
```

- Включение ip forwarding:
```bash
/etc/net/sysctl.conf
	net.ipv4_ip_forward=1
```

 - Включение модуля ядра 8021q:
```bash
modprobe 8021q # включается до перезагрузки
echo "8021q" | tee -a /etc/modules # Постоянное вкл модуля 
```

### Отображение списка фалов и каталогов
#directories
- Команда ls(list)  основные флаги:
```bash
ls -a # Показывает все файлы, включая скрытые(начинаются с точки)
ls -l # Выводит подробнуюю информацию о файлах, включая права доступа, владельца, группу, размер и дату последней модификации
ls -lh # Флаг -h показывает размер файлов в удобочитаемом виде, например в КБ, МБ
ls -R # Рекурсивно выводит содержимое всех подкатологов
ls -lt # Флаг -t сортирует файлы по времени изменения(дефолт: от новых к старым)
ls -S # Сортирует файлы по размеру(дефолт: от больших к меньшим)
ls -lr # Флаг -r инвертирует порядок сортировки(например, для сортировки по времени от старых к новым или от меньших к большим)
ls  -d */ # Показывает информацию о каталоге как о файле(не перечисляет его содержимое)
ls -i # Показывает индексный номер каждого файла
```

- Команда lsblk(list block devices) - предназначена для отображения информации о блоковых устройствах. Точнее отображает список всех доступных блоковых устройств в системе, таких как диски, разделы и их монтированные точки. Основные флаги команды:
```bash
lsblk -a # Показывает все устройства, включая не смонтированные или скрытые устройства
lsblk -f # Показывает файловую систему для каждого устройства, а также информацию о метках и UUID
lsblk -l # Отображает устройства в виде списка(по одному на строку)
lsblk -o NAME,SIZE,TYPE,MOUNTPOINT # Указывает, какие колонки выводить. Можно выбрать, как пример, имя устройства, размер, тип и монтированную точку
lsblk -p # Показывает полный путь устройства
lsblk -r # Не выводит информацию о разделе
lsblk -t # Показывает таблицу всех устройств с их иерархией, к примеру дл яотображения всех разделов и их родителей
lsblk -n # Выводит только имена устройств без заголовков
lsblk -d # Показывает только физические устройства(без разделов)
```

### Добавление нового пользователя
#users
```bash
useradd имя_пользователя
# Флаги:
> -M - не создавать домашний каталог
useradd -M test
> -N - не создавать группу с тем же именем что и у пользователя
useradd -N test
> -p - пароль
useradd -p пароль имя_пользователя
> d - указание кастомного домашнего каталога
useradd -d путь_к_новому_каталогу имя пользователя
> --system - создание системного аккаунта без пароля и домашнего аккаунта
useradd --system test
```
Изменение пользователя
```bash
usermod -L новое_имя старое_имя
```
Смена пароля пользователю
```bash
passwd имя_пользователя
```
Изменение домашнего каталога пользователя
```bash
usermod -d новый_домашнйи_каталог -m имя_пользователя
```
Просмотр списка пользователей
```bash
cat /etc/passwd
```
Удаление пользователя
```bash
userdel имя_пользователя
userdel -f имя_пользователя # Удаляет залогиненнного пользователя
userdel -r имя_пользователя # Удаляет домашний каталог и почтовый ящик
```
Изменение UID и GID пользователя
```bash
usermod -u 777 имя_пользователя
```
### Группы для пользователей
#user_groups
```bash
cat /etc/group # Просмотр списка групп
```
Создание группы
```bash
groupadd имя_группы
```
Удаление группы
```bash
groupdel имя_группы
```

```bash
groups # Узнать группу текущего пользователя
groups имя_пользователя # группа конкретного пользователя
```
Принудительное назначение первичной группы
```bash
usermod -g группа имя_пользователя
```
Добавление в дополнительную группу
```bash
usermod -a -G группа имя_пользователя
```
Удалить пользователя из группы
```bash
gpasswd -d пользователь имя_группы
```

### Управление правами
#rules #users
> [!INFO] Для чего нужна chmod?
> 	chmod(от Change Mode) используется в Linux и других Unix-подобных системах для изменения прав доступа к файлам и директориям. С ее помощью можно управлять тем кто и как может взаимодействовать с файлом - читать, записывать или выполнять его

```bash
chmod <флаг> установка_прав имя_файла
# Пример
> chmod -R 666 /home/test
```

```bash
Двоичная: 0) 000 1) 001 2) 010 3) 011 4) 100 5) 101 6) 110 7) 111
Восьмеричная:
0 --- # прав на файл/директории нет
1 --x # выполнение, на директории: чтение свойств файлов
2 -w- # запись, прав на директории нет
3 -wx # запись и выполнение, на директории: все кроме получения имени файлов
4 r-- # чтение, на директории: чтение имен файлов
5 r-x # чтение и выполнение, на директории: доступ на чтение файлов/их свойств
6 rw- # чтение и запись, на директории: чтение имен файлов
7 rwx # все права, на директории: все права
```

```bash
776, 775, 774, 766, 755 # Чтение, запись и исполнение
655, 644 # Чтение, запись
```

> Команда chown(change owner) - утилита, предназначенная для изменения владельца и/или группы для указанных файлов;

```bash
chown новый_владелец:новая_группа имя_файла
```
Новый владелец файла, пример
```bash
chown test:test /home/test/yes.txt
```
Новый владелец директории
```bash
chown test:test /home/user
# Флаги
> -R - новый владелец директории и его содержимого
```
### NAT через iptables
#iptables #nat
> [!INFO] Что такое iptables?
> Инструмент в Linux, который помогает контролировать, какой интернет-трафик может проходить через компьютер или сервер. Он работает как "фильтр", которые решает разрешить или заблокировать данные, которые приходят или уходят. Например, с его помощью можно запретить доступ к определенным сайтам, разрешить соединение только с определенных ip-адресов или защитить систему от атак.
- Установим нужные нам пакеты для работы:
```bash
apt-get install iptables
> # iptables - Мощный инструмент управления сетью в Linux, который позволяет администраторам управлять входящими и исходящими пакетами данных
```

- Настройка NAT через iptables
```bash
iptables -t nat -A POSTROUTING -o <int_name> -j MASQUERADE # не сохранится после перезапуска
```

- Для сохранения конфигурации NAT:
```bash
iptables-save >> /etc/sysconfig/iptables # Делаем чтобы правило iptables сохранялось
systemctl enable --now iptables # Ставим на автозагрузку при запуске
```
> [!WARNING]
> Для удаления правила, нужно просто убрать строку по пути /etc/sysconfig/iptables связанную с интерфейсом отвечающим за iptables
### Samba DC
#samba #domain
> [!INFO] Что такое Samba DC?
> Программное обеспечение, которое позволяет Linux-серверам работать как контроллеры домена в сети Windows. Он управляет пользователями, компьютерами и доступом к ресурсам в сети, как это делает сервер Windows с Active Directory. С помощью Samba DC можно настроить централизованное управление доступом и безопасность всех устройств в сети, включая Windows, Linux и другие ОС
1. Создание домена [[Samba AD]]
- Задаем имя на устройство:
```bash
> hostnamectl set-hostname test.domain.company 
> или же test.domain.prof

Пример домена:
> ivanov.prof
```
- Зададим доменное имя:
```bash
> domainname test.domain.company
> или же test.domain.prof
```
- В файле конфигурации /etc/resolv.conf впишем домен поиска и IP-Адрес нашего сервера:
```bash
search domain.name
nameserver [адрес сервера]
```

2. Настройка kerberos:
- Конфигурация /etc/krb5.conf:
```
Заменяем EXAMPLE.COM(написанное капсом - на такой же текст, но свой домен), маленькими буквами - аналогично
```
- После проведения конфигурации получаем билет kerberos: 
```
kinit Administrator@domain.name
> Пример: Administrator@ivanov.prof
```

- Для того чтобы узнать какие билеты kerberos были получены, можно использовать следующую команду:
```bash
klist
```

- Установка пакета на сервер:
```bash
apt-get install task-samba-dc
```

- Для дальнейшей развертки samba нужно удалить/создать следующие директории/файлы:
```bash
> rm -f /etc/samba/smb.conf # Перед созданием домена необходимо обязательно удалить данный файл
> rm -rf /var/lib/samba
> rm -rf /var/cache/samba
> mkdir -p /var/lib/samba/sysvol
```

- Создание домена:
```bash
samba-tool domain provision --use-rfc2307 --interactive
Где:
> --use-rfc2307 # Позволяет поддерживать расширенные атрибуты типа UID и GID в схеме LDAP и ACL на файловой системе Linux
> --interactive # интерактивные режим настройки samba
```

- Вывод устройств входящих в домен:
```bash
samba-tool computer-list
```

```
- Для подключения без графики потребуется ПК Администратора, с которого мы будем подключаться к настройке домена, на компьютере администратора нужно установить:
```bash
apt-get install admc gpui
> ADMC - инструмент для работы с доменом Active Directory и групповыми политиками
> GPUI - модуль режактирования настроек клиентской конфигурации, предназначен для настройки и изменения параметров групповой политики.
```
> [!WARNING] Для управления доменом, компьютер администратора должен находится в домене

- Для того, чтобы групповые политики применились на клиентском компьютере, следует установить следующий пакет:
```bash
apt-get install gpupdate
> gpupdate - команда заставляющая компьютер принудительно перечитать все политики с контроллера домена и заново применить все параметры
```
- После установки будет доступна следующая команда:
```bash
gpupdate # прописывается в terminal на клиенте, она должна скзаать о том что групповые политики на Компьютере и Пользоветеле успешно применены
> # Если же такого не выводится или выводится но с ошибкой, значит стоит проверить правильности настройки домена/групповых политик
> # Групповые политики для Компьютера - применяются только для текущего компьютера
> # Групповые политики для Пользователя - применяются для всех пользователей/компьютеров находящихся в домене
```

### Присоединение к домену с помощью realm
```bash
sudo realm discover # Обнаружение домена по умолчанию (из DHCP)
sudo realm discover ad.example.com # Обнаружение конкретного домена
sudo realm join ad.example.com # Присоединение к домену от имени администратора (запросит пароль)
sudo realm join ad.example.com -U username # Присоединение от имени другого пользователя
sudo realm join --user=Администратор ivanov.prof # Пример из вашей записи
realm list # Показать список сконфигурированных доменов
realm permit --all # Разрешить вход всем пользователям домена
realm permit user@domain.com # Разрешить вход конкретному пользователю
realm leave # Отсоединить систему от домена
```
Используемая документация:
- [Руководство: realmd](https://www.freedesktop.org/software/realmd/docs/realm.html) 
- [Проверка доступности и присоединение к домену](https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/windows_integration_guide/realmd-domain)

### Настройка WireGuard VPN
Установка необходимых пакетов [[WireGuard]]:
```bash
apt-get install wireguard-tools wg-quick
```
Базовая настройка:
1) Генерация ключей
```bash
cd /etc/wireguard
umask 077
wg genkey | tee private.key | wg pubkey > public.key
```
2) Создание конфигурации:
```bash
vim /etc/wireguard/wg0.conf
```
Содержимое:
```bash
[Interface]
PrivateKey = <Приватный ключ HQ>
Address = <IP> # IP-Адрес устройства
ListenPort = 51820 # Порт прослушивания

[Peer]
PublicKey = <Публичный ключ BR>
AllowedIPs = 0.0.0.0/0 # Разрешенные сети, в примере, разрешены ВСЕ сети
```
3) Включение перенаправления пакетов:
```bash
vim /etc/sysctl.conf 
# Требуется раскоментировать строку
net.ipv4.ip_forward=1
# После этого, выходим из файла и прописываем:
sysctl -p
```

Управление интерфейсов WireGuard:
```bash
wg-quick up wg0 # Запустить интерфейс wg0
wg-quick down wg0 # Остановить интерфейс wg0
wg show # Показать статус и текущие подключения
systemctl enable wg-quick@wg0 # Добавить автозагрузку при старте системы
```
Настройка клиента:
1) Установим пакет wireguard-tools
```bash
apt-get install wireguard-tools -y
```
2) Поместим конфигурационный файл от администратора сервера в /etc/wireguard
```bash
touch /etc/wireguard/wg0.conf # Создаем файлик wg0.conf
vim !$ # Переходим к редактированию последнего созданного файла (wg0.conf)
# Содержимое файла:
[Interface]
PrivateKey = <Приватный ключ CLI>
Address = 192.168.200.2/24 # IP-Адрес устройства
ListenPort = 51820 # Порт прослушивания

[Peer]
PublicKey = <Публичный ключ SRV>
AllowedIPs = 0.0.0.0/0 # Разрешенные сети, в примере, разрешаются ВСЕ сети
Endpoint = <Адрес SRV>
PersistentKeepalive = 25

```
3) Подключение:
```bash
wg-quick up wg0.conf
```

### Мониторинг системы и сети
#monitoring #system_info
```bash
ps aux # Показать все процессы
top # Интерактивный монитор процессов (аналог диспетчера задач)
htop # Улучшенная цветная версия top (требует установки)
systemctl status <имя_службы> # Проверить статус системной службы
journalctl -u <имя_службы> -f # Просмотреть логи службы в реальном времени
```
Работа с сетевыми портами и соединениями:
```bash
ss -tulpn # Показать все открытые порты и какая программа их слушает
netstat -tulpn # Альтернативная команда (может требовать установки net-tools)
ping <адрес> # Проверить доступность узла в сети
traceroute <адрес> # Проследить маршрут до узла
ip a # Показать информацию о сетевых интерфейсах и их адресах
ip route # Показать таблицу маршрутизации
```
Получение информации о системе:
```bash
cat /etc/os-release # Самая подробная информация о дистрибутиве (имя, версия, кодовое имя)
lsb_release -a # Краткая сводка (работает, если установлен пакет lsb-release)
hostnamectl # Показывает имя хоста, архитектуру, версию ядра и дистрибутива (работает в systemd-системах)
uname -a # Выводит всю основную информацию о ядре: тип системы, имя хоста, версия ядра, дата сборки, архитектура процессора
```
Информация о ядре:
```bash
uname -r # Только версия ядра (самая часто используемая команда)
uname -m # Архитектура процессора (x86_64, aarch64, i686 и т.д.)
uname -s # Только название операционной системы (Linux)
cat /proc/version # Информация о версии ядра, компиляторе и дате сборки
rpm -qa | grep kernel # Показать все установленные пакеты ядра в ALT Linux (RPM-based)
```
Информация о процессоре (CPU):
```bash
lscpu # Детальная информация о CPU: архитектура, ядра, потоки, кэш, частота
cat /proc/cpuinfo # Более низкоуровневая информация о каждом ядре процессора
nproc # Быстро показать общее количество доступных ядер/потоков
```
Информация о памяти (RAM):
```bash
free -h # Показать общий объем, использование и доступную память в человеко-читаемом формате (ГБ/МБ)
cat /proc/meminfo # Полная детализированная информация о памяти (общая, свободная, кэш, swap)
vmstat -s # Статистика использования памяти в более структурированном виде
top или htop # Интерактивный просмотр в реальном времени (в заголовке обычно отображается общий объем и использование)
```
Информация о дисках и файловых системах:
```bash
df -h # Показать свободное место на всех смонтированных файловых системах
lsblk # Дерево блочных устройств (диски, разделы) с размерами и точками монтирования
fdisk -l # Подробная информация о разделах на всех дисках (требует root)
blkid # Показать UUID и тип файловой системы для всех разделов
mount | column -t # Показать список всех смонтированных файловых систем в удобном виде
```
Информация о сети:
```bash
ip addr show # Современная команда для отображения всех интерфейсов и их IP-адресов (аналог ifconfig)
ip link show # Показать состояние сетевых интерфейсов (включен/выключен)
ip route show # Показать таблицу маршрутизации
nmcli device status # Показать статус устройств, управляемых NetworkManager (если используется)
cat /etc/resolv.conf # Показать DNS-серверы, используемые системой

# Некоторые из допустимых сокращений:
ip a
ip -c a # Выделяет "-c" цветом, является более удобочитаемым вариантом 
ip r
ip -c r # Флаг "-c" выделяет цветом, является более удобочитаемым вариантом 
```
Информация об оборудовании (PCI, USB):
```bash
lspci # Показать список всех PCI-устройств (видеокарта, сетевые карты, контроллеры)
lsusb # Показать список всех подключенных USB-устройств
lshw # Очень подробная информация обо всем оборудовании (требует установки пакета lshw и прав root)
dmidecode # Вывести информацию из DMI/SMBIOS таблиц (производитель, модель, серийный номер, BIOS) - требует root
```
Информация о загрузке и uptime:
```bash
uptime # Показать время работы системы, количество пользователей и нагрузку (load average)
who -b # Показать дату и время последней загрузки системы
dmesg | head -30 # Просмотреть первые 30 строк лога ядра (полезно для диагностики загрузки)
journalctl -b # Показать все журналы systemd с момента последней загрузки
cat /proc/loadavg # Текущая нагрузка на систему (1, 5, 15 минут) и количество процессов
```
Сводная информация (полезные утилиты):
```bash
neofetch # Выводит логотип дистрибутива и основную информацию в стильном формате (требует установки)
inxi -Fxz # Выводит чрезвычайно подробный отчет по всем компонентам системы (пакет inxi)
screenfetch # Аналог neofetch (требует установки)
```
### Настройка GRE
#gre #frr_gre
Установка дистрибутива [[Free Range Routing]]
`apt-get update && apt-get install frr -y`
Создание интерфейса:
`mkdir /etc/net/ifaces/gre`
Далее, заполняем конфигурационный файл по пути созданному ранее.
Содержимое `options`:
```bash
TYPE=iptun
TUNTYPE=gre
TUNLOCAL=<wan-local-address>
TUNREMOTE<wan-remote-address>
TUNTTL=64
TUNOPTIONS='ttl 64'
```
Содержимое `ipv4address`:
```bash
10.0.0.1/30
```
Выбранная подсеть: `10.0.0.0/30`, значит на втором сервере будет: `10.0.0.2/30`
Заходим в конфигурационный файл демона FRR:
```bash
vim /etc/frr/daemons
> ospfd=yes # заменяем 'no' на 'yes'
```
Запускаем службу FRR:
```bash
systemctl enable --now frr
```
Следующим шагом, нам нужно объявить сети в FRR:
```bash
vtysh
rtr(config)# interface gre1
rtr(config)#   ip ospf authentication
rtr(config)#   ip ospf authentication-key P@ssw0rd - парольная аутентификация
rtr(config)#   ip ospf network broadcast
rtr(config)#   no ip ospf passive
rtr(config)# exit
rtr(config)# router ospf
rtr(config)#   ospf router-id <R-ID> - Например 1.1.1.1 и 2.2.2.2
rtr(config)#   network 10.0.0.0/30 area 0
rtr(config)#   network 192.168.10.0/27 area 0
и т.д.
Обязательно пропишите для сохранения конфигураций: > do wr
```
После этого, перезапустим службы:
```bash
systemctl restart frr
```